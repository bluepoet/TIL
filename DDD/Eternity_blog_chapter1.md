# PART 1. VALUE OBJECT와 REFERENCE OBJECT

어플리케이션을 구성하는 객체들을 REFERENCE OBJECT와 VALUE OBJECT로 분류할 수 있다.

REFERENCE OBJECT는 고객, 주문과 같이 실 세계의 추적 가능한개념을 표현한다.

스템 내에서 해당 객체를 계속 추적해야 하는가? 객체가 표현하는 개념이 유일하게 하나만 존재해야 하는가?
그렇다면 REFERENCE OBJECT로 만든다. 단지 객체가 추적할 필요가 없는 단순한 값인가?
속성값이 동일하면 동일한 객체로 간주해도 무방한가? 고민할 필요 없다. 그냥 VALUE OBJECT로 만든다.

### 동일함(identical)의 의미

모든 객체 지향 시스템은 생성된 객체에게 고유한 식별자(identity)를 부여한다. 대부분의 객체 지향 언어는 객체가 위치하고 있는 메모리 상의 주소를 객체의 식별자로 할당하고 이 주소 값을 사용하여 객체를 구별한다. 각 언어는 객체의 식별자를 비교할 수 있는 연산자를 제공하는데 Java의 경우 “==”와 “!=” 연산자를 사용한다. 두 참조가 가리키는 객체가 동일한 식별자를 가지는 경우, 즉 동일한 주소에 위치하는 경우 “==” 연산자는 true를 반환한다.

quals() 메소드를 오버라이딩 할 경우에는 hashCode() 메소드도 함께 오버라이딩해주는 것이 좋다. 다음은 금액을 클래스로 작성한 것이다.

각 REFERENCE OBJECT는 유일하기 때문에 동일성 확인 시에 식별자를 사용하는 “==” 연산자를 사용할 수 있다. VALUE OBJECT의 경우 equals() 메소드를 사용하여 속성 값의 동등성을 비교해야 한다.

왜 객체를 비교할 때 “==” 연산자와 equals() 메소드를 구별하여 적용해야 하는가? 근본적으로 REFERENCE OBJECT와 VALUE OBJECT를 구별하는 이유가 무엇인가?   이에 대한 해답은 REFERENCE OBJECT 대신 VALUE OBJECT를 사용함으로써 악명 높은 별칭(aliasing) 문제를 피할 수 있기 때문이다.

### 별칭(aliasing) 문제


java에서는 하나의 객체를 서로 다른 변수가 참조할 수 있다. 이처럼 동일한 객체를 서로 다른 변수가 참조하는 것을 별칭(aliasing)이라고 한다. 


따라서 고객 객체를 다루는 가장 효과적인 방법은 별칭을 만들지 않는 것이다. 이야기가 여기서 끝난다면 프로그래머 생활도 그렇게 험난하지만은 않았을 것이다. 별칭을 만들지 않는 정책의 가장 큰 문제는 별칭이 만들어지는 것을 막을 수 없다는 점이다.
 
동일한 메소드, 동일한 클래스 내에서라면 의식적으로 별칭을 만들지 않을 수 있다. 그러나 해당 객체를 다른 메소드의 인자로 전달하는 순간 별칭 문제는 다시 끔찍한 고개를 쳐들고 코드 언저리를 스멀거리며 돌아다니기 시작한다. 메소드의 인자로 객체를 전달한다는 것은 자동으로 객체의 별칭을 만든다는 것을 의미한다. 이것이 값에 의한 전달(pass-by-value)인가, 참조에 의한 전달(call-by-reference)인가에 관한 논쟁은 중요하지 않다. 여기에서 중요한 것은 메소드를 호출하는 순간 전달된 인자에 대한 별칭이 자동으로 생성된다는 것이다.

객체가 final로 전달되더라도 전달된 객체 자체의 상태를 바꾸는 것이 가능하다는 사실에 주의하자.

```
private void test(final MtaException e) {
    MtaException e1 = new MtaException();
    e = e1; // compile error
}
```


```
private void test(MtaException e) {
    MtaException e1 = new MtaException();
    e = e1; // pass
}
```

좋은 객체 지향 습관을 따른다면 인자로 전달된 객체의 상태를 바꾸는 메소드는 작성하지 않을 것이다. 그러나 세상은 그리 녹녹치 않다. 신뢰할 수 있는 코드보다는 신뢰할 수 없는 코드가 더 많은 것이 각박한 현실이다. 아빠랑 오빠 빼고 다른 남자는 다 믿지 말라는 남자 친구의 말보다 더 믿기 어려운 것이 다른 코드라는 사실을 잊지 말자. 따라서 우리는 가능한 방어적으로 프로그래밍할 필요가 있다.
 
별칭 문제를 해결하기 위한 가장 좋은 방법은 객체를 변경할 수 없는 불변 상태로 만드는 것이다. 전달된 객체가 변경될 수 없다면 메소드에 객체를 전달한다고 하더라도 별칭을 통한 부작용을 막을 수 있다.

### 생명 주기 제어

객체 그래프 상에서 항해를 시작하기 위한 시작 객체를 ENTRY POINT라고 한다. 객체 그룹의 ENTRY POINT는 항상 REFERENCE OBJECT여야 한다. VALUE OBJECT는 ENTRY POINT가 될 수 없다.

시스템은 임의의 ENTRY POINT에 접근 가능해야 한다. 또한 ENTRY POINT는 REFERENCE OBJECT이므로 ENTRY POINT에 접근할 때마다 동일한 객체 인스턴스를 반환 받아야 한다. 이것은 동일한 ENTRY POINT의 요청에 대해 항상 동일한 식별자를 지닌 객체가 반환된다는 것을 의미한다. 따라서 동일한 ENTRY POINT에 대한 요청 결과로 반환 받은 객체들은 “==” 테스트를 통과해야만 할 것이다

ENTRY POINT에 대한 관리 인터페이스를 구성하는 방법에는 두 가지가 존재한다. 

```
각각의 ENTRY POINT가 스스로 관리 인터페이스를 제공한다.
별도의 객체가 ENTRY POINT에 대한 관리 인터페이스를 제공한다
```

코드를 작성하기 전에 테스트를 작성하는 것은 좋은 습관이다. Test-First Approach 또는 Test-Driven Development라고 불리는 이 방법은 우선 실패하는 테스트를 작성한 후 테스트를 성공시키는 방법으로 코드를 작성한다. 
